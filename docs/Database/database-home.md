# おうちで学べるデータベースのきほん

## Chapter01 データベースって何だろう

* 現代はあらゆるものがデータベース化され、データが蓄積されている
* データベースの基本機能
    * データの検索と更新(登録・修正・削除)
    * 同時実行制御: 複数ユーザによる更新の整合性の確保
    * 耐障害性: 壊れにくく、壊れても復旧が可能
    * セキュリティ: データベースをいかに上手く隠すか
* データベースの種類
    * 階層型データベース: 階層構造で管理。
    * リレーショナルデータベース: 二次元表で管理
    * オブジェクト指向データベース: オブジェクトで管理
    * XMLデータベース: XML形式で管理
    * NoSQLデータベース: Not Only SQL

## Chapter02 リレーショナルデータベースって何だろう

リレーショナルデータベース(Relational DataBase; RDB)は、下記の特徴を持つ。
* リレーション、つまり二次元表を使って管理する
* SQL(Structured Query Language)によるデータの操作が非常に簡単である
    * SELECT: 検索コマンド
    * INSERT: 登録コマンド
    * UPDATE: 更新コマンド
    * DELETE: 削除コマンド

データベースを実現するための具体的なソフトウェアのことを、DBMS(DataBase Management System)という。
DBMSには、OracleやMySQL、PostgresSQLなどがある。

実際のシステムは、OSとミドルウェアとアプリケーションの3階層のソフトウェアを組み合わせて作られる。
OSとは、システムが動作するための一番の土台となる機能を提供するソフトウェアである。
ミドルウェアとは、OSとアプリケーションの間で動くソフトウェアのことである。
データベースはミドルウェアに属するソフトウェアである。
アプリケーションとは、業務的な機能を持つようプログラムされたソフトウェアである。
ユーザが最も頻繁に触るソフトウェアである。

OSとデータベースは、予算や機能、開発者・運用者のスキルによって組み合わせて使用する。
データベースとアプリケーションの関係性としては、アプリケーションがユーザとデータベースの間に入っているのが重要である。
つまり、ユーザがアプリケーションを介してデータベースにアクセスするということであり、これはセキュリティやシステム開発の点で利点がある。


## Chapter03 データベースにまつわるお金の話

イニシャルコストとランニングコストがかかる。
イニシャルコストは、エディションとオプションによって増減がある。
ランニングコストは、サポート料である。何かしらの問題が起きた時の責任の分散になる。

コストは、イニシャルコストとランニングコストの両方を含めたトータルコストで考える癖をつけるのが重要である。

## Chapter04 データベースとアーキテクチャ構成

アーキテクチャとは、構成という意味であり、
システムを作り上げるための物理レベルの組合せという意味である。

アーキテクチャの設計は、サーバやOS、他のミドルウェアに加えネットワーク機器などの知識が必要で非常に難しい。
一方で、アーキテクチャ設計が出来なければ、システム構築にかかるコストを算出できないため、アーキテクチャ設計は非常に重要である。

### DBのアーキテクチャの歴史

1. スタンドアロン
    1. ネットワークに接続されておらず、単独で動作するマシン
    2. 利点は、構築が簡単で、セキュリティは高い
    3. 欠点は、離れた場所から作業付加、複数ユーザの同時作業不可、可用性が低い、拡張性が乏しい。
2. クライアント/サーバ(クラサバ)
    1. DBサーバ1台に対して、複数のユーザ端末がアクセスするタイプの構成
    2. 欠点は、インターネットから直接DBにアクセス出来るセキュリティリスクと多数のユーザのクライアント上でアプリケーションを管理するコストが高いこと
3. Web3層
    1. Webサーバ層・アプリケーション層・データベース層
    2. クライアントとDBサーバの間にWebサーバ層とアプリケーション層が追加された。
    3. これにより、クラサバのセキュリティリスクと管理コストを改善

### 可用性と拡張性の確保

* 可用性(Availabity): 障害なくサービスを継続できる程度を表す概念
    * 心臓戦略: 高品質-少数戦略。
    * 腎臓戦略: 低品質-多数路線。クラスタリング(同じ機能を持つ構成を並列化させること)->冗長化。
        * 収穫逓減の法則: 数を増やせば増やすほど、1つあたりから得られる効果が減ること。
        * 単一障害点(SPOF; Single Point of Failure): 全体の強度は最も弱いところの強度で決まる
* 拡張性(Scalability): 必要に応じて機能をどの程度向上させられることができるのかを表す概念

* 信頼性: システムを構成するコンポーネントの故障率

### DBサーバの冗長化: クラスタリングとレプリケーション

DBサーバはデータを永続的に貯める必要があり、かつパフォーマンスを求められる。
実際は、専用の外部ストレージとセットでDBサーバのアーキテクチャは考える。
大きく、クラスタリングとレプリケーションの二つがある。

* クラスタリング: DBサーバのみを冗長化する
  * シェアードナッシング: DBサーバとストレージのセットを増やし、並列処理を行うことで、パフォーマンスを上げる。カバーリング等が必要になる
  * シェアードディスク: 複数のDBサーバが1つのストレージを共有している(ストレージがボトルネックになることも)
    * Active-Active構成: DBサーバが同時稼働している
      * 1つのDBサーバがダウンしても、システムは継続できる
      * CPUやメモリが増えるため、パフォーマンスの向上も見込める
    * Active-Standby構成: アクティブ型以外のDBサーバは待機している
      * Hot-Standby: 常にDBサーバは起動され、トラブル時に切り替わる
      * Cold-Standby: 普段は起動されており、トラブル時に起動して、切り替わる
* レプリケーション: DBサーバとデータを冗長化する
  * マスタスレーブ: 元になるDBをマスタ、同期される側をスレーブ。
  * マルチマスタ: マスタが2つある構成。あまり見かけない。


## Chapter5 DBMSを操作する際の基本知識

MySQLのインストール方法は省略

DBMSを使う際にはまずコネクションを確立させる必要がある。
それはログインをするようなもの。
データベースには、SQL以外にもコマンドを入力することができる。
一般的なものはなくて、DBMS独自に存在する。

### リレーショナルデータベースの階層
データベースは3 or 4つの階層からなる。
* インスタンス
  * 実際にOS上に存在するプロセス
* データベース
  * 階層の一つである
* スキーマ
  * ディレクトリのようなものである
* テーブル(オブジェクト)
  * テーブル以外にも、インデックスやストアドプロシージャなど、総称してオブジェクトが保存される

ただし、DBMSによっては、データベースがなく、3層になっている場合もある。
ANSIの標準SQLによると、4層が正確である。


## Chapter06 SQL文の基本を学ぼう

SQL文は大きく3つに分けられる。
* DDL(Data Definition Language): データ定義言語
    * データベースやテーブルなどを作成したり、削除したりする
    * e.g.) `CREATE`, `DROP`, `ALTER`
* DML(Data Maniulation Language): データ操作言語
    * データの行を検索したり、変更したりする
    * e.g.) `SELECT`, `INSERT`, `UPDATE`, `DELETE`
* DCL(Data Control Language): データ制御言語
    * データベースに対して行った変更を確定したり取り消したりする
    * e.g.) `COMMIT`, `ROLLBACK`

```
SELECT DISTINCT xxx FROM db1.table1 WHERE yyy='hoge';
```
db1というデータベースのtable1テーブルから(FROM db1.table1)、yyy列が'hoge'である行のうち(WHERE yyy='hoge')、xxx列のみを重複なし(DISTINCT)で抽出する(SELECT xxx)。


### よく使うSQLの操作コマンド

* `SHOW databases;`
  * データベースの一覧を表示する
* `SHOW tables;`
  * データベースに格納されているテーブルの一覧を表示する
* `USE db1;`
  * データベースを選択する

### よく使うSQLコマンド(SELECT文)

* `SELECT (DISTINCT) column1`
  * (重複行を省いて)列を選ぶ
* `FROM db1.table1`
  * データベースDBのtable1というテーブルを選ぶ
* `WHERE col1='hoge' AND col2>100`
  * 条件に合致する行を抽出する
* `GROUP BY xxx`
  * グループに分ける
* `COUNT(), MIN(), MAX(), SUM(), AVG()`
  * 関数を用いて集約する
* `GROUP_CONCAT`
  * 文字列を集約する
* `HAVING yyy`
  * グループ毎に集約した値を条件にしたい場合に使用する
* `ORDER BY xxx (DESC)`
  * xxxを基準に並び替える．
  * DESCがある場合，降順になる．

SELECTを使うSQL文は，必ず次の順番で記述する必要がある．
1. `SELECT`
2. `FROM`
3. `WHERE`
4. `GROUP BY`
5. `HAVING`
6. `ORDER BY`

### データの更新・挿入・削除
* `UPDATE table1 SET col1=xxx, col2=yyy WHERE 条件;`
  * データを更新する
* `INSERT INTO table1 (col1, col2) VALUES (val1, val2);`
  * データを挿入する
  * 列名は記述しなくても良いが，その場合，値は列の順番通りに設定する必要がある
  * 列と値はすべてえ記入しなくてもよく，その場合はデフォルト値が入る
  * テーブルや列の情報は，`SHOW CREATE TABLE table1`や`DESC table1`で確認できる
* `DELETE FROM table1 WHERE 条件`
  * データを削除する

並び替え(`ORDER BY`)や集約(`MAX(xxx)`, `COUNT(*)`)、グループ分け(`GROUP BY`)等も行う事が出来る。


### ビューの作成と副問い合わせ、結合

ビュー(view)は、テーブルと同じように扱えるが、テーブルのようにデータは持たずに、テーブルに対する`SELECT`をもっている。
次のような利点がある。

1. 複雑なSELECT文をいちいち毎回記述する必要がなくなる
2. 必要な列、行だけをユーザに見せることができ、更新時にもビュー定義に沿った更新に限定することができる
3. 1と2の利点をデータ格納なしに実現でき、ビューを削除しても参照しているテーブルは影響を受けない

`CREATE VIEW VIEW_NAME col1 col2 AS SELECT 文;`


副問い合わせ(サブクエリ)とは、`SELECT`文の中に`SELECT`文を入れ子状態にしたものである．
副問い合わせは、テーブルのように扱ったり、数値のように扱って条件文に利用したりできる。

結合(join)とは、あるテーブルに別のテーブルの列を持ってくる操作のことである。
この時、行を合わせるための条件を「結合条件」という。
結合の仕方には複数あるが、ここでは**内部結合**(inner join)と**外部結合**(outer join)を述べる。

* 内部結合
    * 結合条件に一致する行のみを2つのテーブルから持ってくる
    * `SELECT 選択したい列のリスト FROM table1 INNER JOIN table2 ON 結合条件`
* 外部結合
    * 指定したテーブルを基準にしてすべての行を表示し、もう一方のテーブルは値があれば表示する
    * `SELECT 選択したい列のリスト FROM table1 LEFT OUTER JOIN table2 on 結合条件`


## Chapter07 トランザクションと同時実行制御

トランザクション: 複数のクエリを連続的に用いた時のひとまとまりのクエリの処理単位のことである。
トランザクションは、ユーザが開始と終了を定義すること(`COMMIT`や`ROLLBACK`)が可能である。
一方で、ユーザが意識せずともコミットされる場合がある。
DBMSによるが、DDLを発行時に暗黙のコミットがされることがある。
また、自動コミットという機能があり、1つのSQL文が1つのトランザクションとして区切られコミットされる。

トランザクションは4つの特性、ACID特性によって定義される。

* Atomicity(原子性)
    * データの変更(INSERT/UPDATE/DELETE)を伴う一連のデータ操作が全部成功/失敗するかを保証する仕組みである
    * すべての操作が上手くいく場合は、`COMMIT`を発行して処理を確定させる
    * 途中でエラーが発生したなど、`COMMI`Tされない場合はすべてROLLBACKする
* Consistency(一貫性)
    * 一連のデータ操作の前後で、データベースオブジェクトの整合性を保つことである
* Isolation(分離性もしくは隔離性、独立性)
    * 複数のユーザが同時にデータ操作を行う場合、それぞれの処理が矛盾なく行えることを保証することである
    * 「矛盾がない」とは、複数のトランザクションを順次実行した場合と同じ結果が得られる状態のことである
    * その仕組みとして、データベースオブジェクト(表全体や行など)をロックして、後続の処理を防ぐ方法がある
    * パフォーマンスも考慮して、分離性にはいくつかのレベルがある
* Durability(持続性)
    * トランザクションを完了(`COMMIT`)し、完了通知をユーザが受けた時点で、その操作が永続的となり、結果が失われないこと。
    * これは、DBサーバやOSの異常終了、つまりシステム障害に耐えうるということである。
    * トランザクションをストレージ内にログとして記録し、異常が発生したらそのログを用いて異常発生前の状態まで復旧することで持続性を実現する

### 分離性のレベルと緩和によっておこる現象

分離レベルを緩和することによって、以下の3つの現象が起こる場合がある。

1. ダーティリード(Dirty Read)
   1. トランザクションがコミットされる前に、別のトランザクションからデータを読み出せてしまう現象
2. 曖昧な読取(Fuzzy Read)
   1. あるトランザクションが、以前読み込んだデータを再度読み込んだ時、2回目の結果が1回目の結果と異なる現象
3. ファントム(Phantom)
   1. あるトランザクションを読み込んだ時、選択できるデータが現れたり消えたりする現象

### トランザクション分離レベル

分離性のレベルはANSIによって規格が定義されている。
数字が大きいほど厳格になっていく

1. 非コミット読み取り(Read Uncommitted)
   1. 上記3つの現象すべてが起こりうる
   2. MVCC(Multi Versioning Concurrency Control)が使われる場合、読取がブロックされることはないので、現在のほとんどの場面で使われない。
2. コミット済み読み取り(Read Committed; RC)
   1. クエリを発行した時点でコミットされているデータを読み込む。(つまり、最新のクエリの実行開始時点でコミットされたデータを読み込む)
   2. 曖昧な読取とファントムが起こりうる
3. 再読み込み可能可能読み取り(Repeatble Read; RR)
   1. 初回クエリを発行した時点でコミットされているデータを読み込む(つまり、複数回のクエリの間に他トランザクションがコミットしても、その内容は反映されない)
   2. ファントムが起こりうる。
   3. MySQLのデフォルトの設定である。
4. 直列化可能(Serializable)
   1. どれも起こりえず、最も厳格である。


MySQLでは、DBMSで現在主流のMVCC(Multi Versioning Concurrency Control)という技術を用いられており、以下の特性を持っている。

1. 更新と読込は互いにブロックしない(読込と読込もお互いにブロックしない)
2. 読込内容は、分離レベルにより内容が変わる場合がある
3. 更新の際は、ロックを取得する。ロックは基本的に行単位で取得し、トランザクションが終了するまで保持する。
4. 更新と更新は、後から北トランザクションがロックを取得しようとしてブロックされる。一定時間待ってその間にロックが取得できない場合には、ロック待ちタイムアウトとなる
5. 更新した場合、更新前のデータをUNDOログとしてロールバックセグメントという領域に持つ。UNDOログは、更新したトランザクションのロールバック時に更新前に戻したり、複数のトランザクションから分離レベルに応じて対応する更新データを参照するために利用される。


### ロックタイムアウトとデッドロック

* ロックタイムアウト(Lock Timeout)
    * 更新と更新がぶつかった場合、後から来た更新は待ち状態になる
    * 後から来た更新はロック元がいつ解放されるか不明なので、待つ・待たない、待つならどの程度待つかを設定できるようになっている。
    * ロックタイムアウトが起こった場合、トランザクション全体をロールバックするか、クエリだけロールバックされるかはDBMSや設定によって異なる。
* デッドロック(Deadlock)
    * 複数のトランザクションが、別々の資源に対してロックを取得している状態で、お互いにロック済み資源に対してロックが必要な処理を行ったとき、いくら待っても状況が変わらない状態のこと。
    * デッドロックは独自に検知され、どちらかのトランザクションを開始時点までロールバックする
    * デッドロックは一般的なDBではなくすことができず、デッドロックの対策に加え、デッドロックが起きた時にトランザクションを再実行できるようにしておく必要がある

* デッドロックの対策方法
    * トランザクションを頻繁にコミットする
    * 資源にアクセス順番を決めておく
    * 必要がない場合にはロック読取の利用を避ける
    * ロック範囲をより小さくする
    * 1つのテーブルの複数行に対して複数のコネクションから更新を行う場合は、同時実行性は落ちるが、テーブル単位でロックすることも検討する。
    * MySQLの場合、テーブルに適切なインデクスを追加して、クエリがそれを利用するようにする

### やってはいけないトランザクション処理

* オートコミット
    * オートコミットとは、クエリごとにコミットする設定
    * 特にアプリケーションを実行する際は、適切な単位とトランザクション分離レベルでトランザクションを利用する
* ロングトランザクション
    * トランザクションの同時実行性やリソースの有効利用性の低下に加え、タイムアウト、デッドロックなどが起こりやすくなる
    * 適切なサイズのトランザクションに区切ったり、トランザクション内に対話処理をいれない、不用意にトランザクション数を増やさない(コネクション数を制限する)などの対応を考える

トランザクションには分離レベルやコミット指定など、設定することが数多くあり、それらはシステムの要件やアプリケーションのロジックに合わせて、決める必要がある。

## Chapter08 テーブル設計の基礎

### テーブル設計の基礎

* リレーショナDBでは、すべてのデータはテーブルで管理される。
* テーブルは、共通の属性を持った集合であり、現実世界を写し取ったものである。
* テーブルは、集合であり、関数である
* テーブルは人間の認識を反映して作る事が出来るため、自由に設計することができる。そのため、いくつかのルールがある
  * 最も上位の概念集合にまとめる
  * 「列」は個体の「属性」である
  * 他と重複しない主キー(識別子)を与える
  * 正規形を意識する

### 関数従属性
* 関数従属性(Functional Dependency)
  * 主キーと他の列の間に成立する関数的な一意制のこと
  * 列 = func(主キー)
  * `{主キー1, 主キー2, ..., 主キーN} -> {列}` と記述できる
* 部分関数従属性
  * 主キーを構成する列の一部にだけ関数従属する列が存在すること
  * 部分関数従属がある場合、そのキーと従属する列だけを別テーブルとして外に出す
* 推移関数従属
  * 主キー以外のキー同紙に発生する関数従属のこと
  * 主キーから見て、2段階の関数従属が存在すること
  * テーブルを分割する

### 正規形(Normal Form)

正規形は、テーブルの異常更新の頻度を低下させ、機能的なテーブルにするためのルールである。

* 第1正規形
  * テーブルのセルは、スカラー値(単独の値)である
* 第2正規形
  * 部分関数従属がない
  * 部分関数従属がある場合、主キーと従属する列は別テーブルにする
* 第3正規形
  * 推移関数従属がない
  * それぞれのテーブルを別々にする
* 第4正規形
* 第5正規形

### ER図(Entity-Relational Diagram)

ER図とは、テーブル間の関連性を図示したグラフである。
いくつか表記方法があるが、ここではIE表記法(Information Engineering)を取り上げる。

ER表記法
1. エンティティを作成する
   1. 上半分に主キーを記入し、PK(Primary Key)を後ろに記述する。
   2. 下側に重要な列名を記入する。外部キーの場合、FK(Foreign Key)を後ろに記述する。
   3. 外部キーとは、他のテーブルにおいて主キーとして同じ意味で使用される列のこと。他のテーブルに存在しないと、今のテーブルに存在できない制約を、**外部キー制約**という。
2. リレーションシップを書き込む
   1. 外部キーと他のテーブルの主キー列をつなげる
   2. この時、主キーがあるテーブルと外部キーがあるテーブル間のレコード数の対応関係を記号で表現する。
   3. 対応関係の記号は3種類「0 / 1 / 2以上」があり、複数の記号を同時に用いても良い(0と2以上など)

## Chapter09 バックアップとリカバリ

### 持続性とパフォーマンスを両立させる仕組み

トランザクションにはACID特性があり、DはDurabirity(持続性)で、一連のデータ操作が完了し、完了通知をユーザが受けた時点で、その操作が永続的になり、結果が失われないことになる。
つまり、システム障害に耐えうるということである。
DBMSは、次の仕組みにより持続性とパフォーマンスを両立させている。

* ログ先行書き込み(WAL; Write Ahead Log)
    * まずは、変更内容を記述したログレコードを書き込み、同期する仕組みである
    * 3つの利点がある
        * ディスクに対して連続的に書き込むため、ランダムに書き込むよりもパフォーマンスが良い
        * ディスクへの書き込み容量・回数を減らすことができる
        * データベースバッファを利用して、DBのデータファイルへの変更を効率よく行える
* データベースバッファ
    * データファイルへの入出力をデータベースバッファ経由に一本化して単純化している
* クラッシュリカバリ
    * WALとデータベースファイルのチェックポイント後の更新情報を用いて、データベースファイルをクラッシュ時までにコミットされた最新の状態まで戻す(ロールフォワード)

### バックアップとリカバリ

PITR(Point in the recovery)とは、ある時点からのデータ変更を含めたリカバリのこと。
ある時点のバックアップとそれ以降の更新のログを保存(アーカイブ)しておき、リストアしたデータベースに順次反映することで、バックアップ時以降の任意の時点にリカバリできる。


バックアップは3つの観点から分類できる。

1. ホットバックアップ/コールドバックアップ
   1. バックアップ中にDBが稼働しているかどうかで分類する
   2. ホットバックアップは、DBを稼働させながらデータベース側の機能でバックアップを作成する
   3. コールドバックアップは、DBを停止させ、OS側の機能でバックアップを作成する。
2. 論理バックアップ/物理バックアップ
   1. データの形式で分類する
   2. 論理バックアップは、SQLベースのバックアップで、テキスト形式に準じるフォーマットでバックアップデータが記録される。編集可能で移植性に優れるが、サイズが大きくなったりリストアに時間がかかる。
   3. 物理バックアップは、データ領域をそのままダンプするイメージで、バイナリ形式に準じるフォーマットで記録される。高速だが、同一のDBMSしか出来ない。
3. フルバックアップ/部分(増分・差分)バックアップ
   1. バックアップ時の対象とそれによるデータ量の観点から分類する
   2. フルバックアップは、毎回データベース全体をバックアップする。リストア処理は単純だが、データ量・時間がかかる
   3. 差分バックアップは、直近のフルバックアップ以降に更新されたデータをバックアップすること。フルバックアップよりもデータ量・時間は削減できる。
   4. 増分バックアップは、直近のバックアップ(例えば前日のバックアップ)以降に更新されたデータをバックアップすること。データ量・時間はより削減できるが、順番通りにリストアする必要がある

### データベース管理の注意点

* 障害が起こることを前提に、対策を講じる必要がある
* バックアップファイルは、物理的に離れた場所に置くことが重要である。
* バックアップは基本的にはフルバックアップだが、必要に応じて差分/増分バックアップを検討する
* バックアップにかかる時間と負荷、リストア・リカバリにかかる時間を考慮して、バックアップの手法を選択する


## Appendix パフォーマンスを考えよう

### システムのパフォーマンス

システム世界では、2つのパフォーマンスがある
* 処理時間(プロセスタイムや応答時間(レスポンスタイム)
  * ある特定の処理開始から終了までにかかる時間
* スループット(throughput)
  * 単位時間あたりに処理できる数
  * スループットによって、システムのリソースキャパシティが決定される

システムは、同時に実行される処理量が最も大きくなるタイミングを想定してリソースを用意しておく必要がある。
そうでないと、ピーク時にある地点(**ボトルネック**)から、極端な遅延を引き起こすことになるからである。
ピークを想定したリソースを確保することを、サイジング(Sizing)やキャパシティプランニング(Capacity Plannning)と呼び、システムの要件定義段階において重要である。
ただし、ピーク時と通常時に大きな乖離がある場合、リソースに無駄が生じることになる。
そこで、クラウドを利用して、動的にリソースを変更させることで、ピークを対応する方法もある。

### データベースはなぜボトルネックになるのか

データベースはシステムにおいてボトルネックになりやすいポイントである。
その理由は、下記2点である。
1. 扱うデータ量が最も多い
2. リソース増加による解決が難しい

